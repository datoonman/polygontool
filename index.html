<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Polygon Validator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2563eb 0%, #1e40af 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .subtitle {
            opacity: 0.9;
            font-size: 1.1em;
        }

        .controls {
            padding: 20px 30px;
            background: #f8fafc;
            border-bottom: 2px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 20px;
        }

        .toggle-group {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .toggle-label {
            font-weight: 600;
            color: #334155;
            font-size: 0.95em;
        }

        .mode-label {
            font-size: 0.85em;
            color: #64748b;
            font-weight: 500;
        }

        .toggle-switch {
            position: relative;
            width: 60px;
            height: 30px;
            background: #cbd5e1;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .toggle-switch.active {
            background: #2563eb;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 24px;
            height: 24px;
            background: white;
            border-radius: 50%;
            top: 3px;
            left: 3px;
            transition: all 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .toggle-switch.active::after {
            left: 33px;
        }

        .mode-selector {
            display: flex;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .mode-btn {
            padding: 12px 30px;
            border: none;
            background: white;
            color: #64748b;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            font-size: 1em;
        }

        .mode-btn.active {
            background: #2563eb;
            color: white;
        }

        .mode-btn:hover:not(.active) {
            background: #f1f5f9;
        }

        .content {
            padding: 30px;
        }

        .view {
            display: none;
        }

        .view.active {
            display: block;
        }

        .single-layout {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }

        .map-container {
            width: 100%;
            height: 450px;
            background: #f8fafc;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            position: relative;
            overflow: hidden;
        }

        .map-canvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        .results-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
        }

        .results-table th {
            background: #2563eb;
            color: white;
            padding: 16px;
            text-align: left;
            font-weight: 600;
            font-size: 0.9em;
        }

        .results-table td {
            padding: 16px;
            border-bottom: 1px solid #e2e8f0;
            font-size: 0.95em;
        }

        .results-table tr:last-child td {
            border-bottom: none;
        }

        .results-table tr:hover {
            background: #f8fafc;
        }

        .status-badge {
            display: inline-block;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.85em;
            font-weight: 600;
            margin: 2px;
        }

        .status-valid {
            background: #dcfce7;
            color: #166534;
        }

        .status-error {
            background: #fee2e2;
            color: #991b1b;
        }

        .status-warning {
            background: #fef3c7;
            color: #92400e;
        }

        .status-info {
            background: #dbeafe;
            color: #1e40af;
        }

        .map-btn {
            background: #2563eb;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 600;
            transition: all 0.3s;
        }

        .map-btn:hover {
            background: #1e40af;
            transform: translateY(-1px);
        }

        .json-input-container {
            position: relative;
        }

        .json-input {
            width: 100%;
            min-height: 200px;
            padding: 16px;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            resize: vertical;
            transition: all 0.3s;
            line-height: 1.6;
        }

        .json-input:focus {
            outline: none;
            border-color: #2563eb;
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        .json-display {
            margin-top: 20px;
            padding: 16px;
            background: #f8fafc;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            line-height: 1.8;
            max-height: 300px;
            overflow-y: auto;
        }

        .json-display-title {
            font-size: 0.9em;
            font-weight: 600;
            color: #475569;
            margin-bottom: 8px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        .coord-highlight {
            cursor: pointer;
            transition: all 0.2s;
            padding: 2px 4px;
            border-radius: 3px;
        }

        .coord-highlight:hover {
            background: #dcfce7;
            color: #16a34a;
        }

        .coord-highlight.active {
            background: #dcfce7;
            color: #16a34a;
            font-weight: bold;
        }

        .btn-primary {
            background: #2563eb;
            color: white;
            border: none;
            padding: 14px 32px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 1em;
            transition: all 0.3s;
            margin-top: 15px;
            width: 100%;
        }

        .btn-primary:hover {
            background: #1e40af;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.3);
        }

        .upload-zone {
            border: 3px dashed #cbd5e1;
            border-radius: 12px;
            padding: 60px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: #f8fafc;
        }

        .upload-zone:hover {
            border-color: #2563eb;
            background: #eff6ff;
        }

        .upload-zone.dragover {
            border-color: #2563eb;
            background: #dbeafe;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 1000;
            backdrop-filter: blur(4px);
        }

        .modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .modal-content {
            background: white;
            border-radius: 16px;
            width: 100%;
            max-width: 1200px;
            max-height: 90vh;
            overflow: hidden;
            box-shadow: 0 25px 50px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            padding: 24px 30px;
            background: linear-gradient(135deg, #2563eb 0%, #1e40af 100%);
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h2 {
            font-size: 1.5em;
        }

        .close-btn {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            font-size: 1.5em;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-btn:hover {
            background: rgba(255,255,255,0.3);
            transform: rotate(90deg);
        }

        .modal-body {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .modal-map {
            flex: 2;
            height: 500px;
            border-right: 2px solid #e2e8f0;
        }

        .modal-sidebar {
            flex: 1;
            padding: 24px;
            overflow-y: auto;
            background: #f8fafc;
        }

        .node-list {
            list-style: none;
        }

        .node-item {
            padding: 12px;
            margin: 8px 0;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid transparent;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .node-item:hover {
            border-color: #2563eb;
            transform: translateX(4px);
        }

        .node-item.duplicate {
            background: #fee2e2;
            border-color: #ef4444;
        }

        .node-item.start-node {
            background: #fef3c7;
            border-color: #f59e0b;
        }

        .node-item.end-node {
            background: #f1f5f9;
            border-color: #cbd5e1;
            opacity: 0.7;
            cursor: default;
        }

        .node-item.end-node:hover {
            transform: none;
        }

        .node-item.active {
            background: #dcfce7;
            border-color: #16a34a;
            transform: translateX(8px);
        }

        .node-item.end-node.active {
            transform: none;
        }

        .node-coords {
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: #64748b;
            margin-top: 4px;
        }

        .section-title {
            font-size: 1.1em;
            font-weight: 600;
            color: #1e293b;
            margin-bottom: 16px;
            padding-bottom: 8px;
            border-bottom: 2px solid #e2e8f0;
        }

        .hidden {
            display: none;
        }

        .file-input {
            display: none;
        }

        .upload-icon {
            font-size: 3em;
            color: #2563eb;
            margin-bottom: 16px;
        }

        .empty-state {
            text-align: center;
            padding: 60px;
            color: #94a3b8;
        }

        .empty-state-icon {
            font-size: 4em;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        .help-btn {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, #2563eb 0%, #1e40af 100%);
            color: white;
            border: none;
            font-size: 1.8em;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.4);
            transition: all 0.3s;
            z-index: 999;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .help-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(37, 99, 235, 0.5);
        }

        .help-content {
            max-height: 70vh;
            overflow-y: auto;
            padding: 30px;
        }

        .help-content h3 {
            color: #1e293b;
            margin-top: 24px;
            margin-bottom: 12px;
            font-size: 1.2em;
        }

        .help-content h3:first-child {
            margin-top: 0;
        }

        .help-content p, .help-content ul {
            color: #475569;
            line-height: 1.8;
            margin-bottom: 12px;
        }

        .help-content ul {
            margin-left: 20px;
        }

        .help-content li {
            margin-bottom: 8px;
        }

        .help-content code {
            background: #f1f5f9;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: #dc2626;
        }

        .help-content .example {
            background: #f8fafc;
            padding: 16px;
            border-radius: 8px;
            border-left: 4px solid #2563eb;
            margin: 16px 0;
        }

        @media (max-width: 1024px) {
            .single-layout {
                grid-template-columns: 1fr;
            }
            
            .modal-body {
                flex-direction: column;
            }
            
            .modal-map {
                border-right: none;
                border-bottom: 2px solid #e2e8f0;
                height: 300px;
            }
            
            .modal-sidebar {
                max-height: 300px;
            }
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            h1 {
                font-size: 1.8em;
            }
            
            .controls {
                padding: 15px 20px;
            }
            
            .content {
                padding: 20px;
            }
            
            .mode-selector {
                width: 100%;
            }
            
            .mode-btn {
                flex: 1;
                padding: 10px 15px;
                font-size: 0.9em;
            }
            
            .mode-btn.bulk-mode {
                display: none;
            }
            
            .map-container {
                height: 300px;
            }
            
            .help-btn {
                width: 50px;
                height: 50px;
                font-size: 1.5em;
                bottom: 20px;
                right: 20px;
            }
            
            .results-table {
                font-size: 0.85em;
            }
            
            .results-table th,
            .results-table td {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🗺️ Polygon Validator</h1>
            <p class="subtitle">Validate and visualize polygon geometries</p>
        </div>

        <div class="controls">
            <div class="toggle-group">
                <span class="toggle-label">Coordinate Mode:</span>
                <span class="mode-label">Origin (Lat, Long)</span>
                <div class="toggle-switch" id="coordToggle"></div>
                <span class="mode-label">Orbit (Long, Lat)</span>
            </div>

            <div class="mode-selector">
                <button class="mode-btn active" data-mode="single">Single Polygon</button>
                <button class="mode-btn bulk-mode" data-mode="bulk">Bulk Upload</button>
            </div>
        </div>

        <div class="content">
            <div class="view active" id="singleView">
                <div class="single-layout">
                    <div>
                        <h3 style="margin-bottom: 12px; color: #1e293b;">Visualization</h3>
                        <div class="map-container">
                            <canvas class="map-canvas" id="singleCanvas"></canvas>
                        </div>
                        <div id="singleResults"></div>
                    </div>
                    
                    <div>
                        <h3 style="margin-bottom: 12px; color: #1e293b;">Paste Polygon JSON</h3>
                        <div class="json-input-container">
                            <textarea class="json-input" id="jsonInput" placeholder='{"type":"Polygon","coordinates":[[[6.233,0.700],...]]]}'></textarea>
                        </div>
                        <button class="btn-primary" onclick="validateSingle()">Validate Polygon</button>
                        
                        <div id="jsonDisplay" class="hidden">
                            <div class="json-display-title">Currently checking this JSON:</div>
                            <div class="json-display" id="jsonDisplayContent"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="view" id="bulkView">
                <div class="upload-zone" id="uploadZone" onclick="document.getElementById('fileInput').click()">
                    <div class="upload-icon">📁</div>
                    <h3>Drop your file here or click to browse</h3>
                    <p style="color: #64748b; margin-top: 8px;">Supports CSV, XLSX, XLS</p>
                    <p style="color: #64748b; margin-top: 4px; font-size: 0.9em;">Required columns: <code>ID</code> and <code>Polygon</code></p>
                    <input type="file" id="fileInput" class="file-input" accept=".csv,.xlsx,.xls" onchange="handleFile(event)">
                </div>

                <div id="bulkResults"></div>
            </div>
        </div>
    </div>

    <button class="help-btn" onclick="openHelp()">?</button>

    <div class="modal" id="vizModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modalTitle">Polygon Visualization</h2>
                <button class="close-btn" onclick="closeModal('vizModal')">×</button>
            </div>
            <div class="modal-body">
                <div class="modal-map">
                    <canvas class="map-canvas" id="modalCanvas"></canvas>
                </div>
                <div class="modal-sidebar">
                    <div class="section-title">Nodes (<span id="nodeCount">0</span>)</div>
                    <ul class="node-list" id="nodeList"></ul>
                </div>
            </div>
        </div>
    </div>

    <div class="modal" id="helpModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>📚 User Guide</h2>
                <button class="close-btn" onclick="closeModal('helpModal')">×</button>
            </div>
            <div class="help-content">
                <h3>🎯 Overview</h3>
                <p>This tool validates polygon geometries and checks for common issues like self-intersection, duplicate nodes, and winding direction.</p>

                <h3>🔄 Coordinate Modes Explained</h3>
                <p><strong>IMPORTANT:</strong> The coordinate mode tells the tool how to interpret the order of numbers in your JSON coordinates.</p>
                
                <p><strong>Origin Mode (Lat, Long)</strong>: Your JSON has coordinates in <code>[Latitude, Longitude]</code> order</p>
                <div class="example">
                    Example: <code>[0.700, 6.233]</code> means the FIRST number is Latitude, SECOND is Longitude
                </div>
                
                <p><strong>Orbit Mode (Long, Lat)</strong>: Your JSON has coordinates in <code>[Longitude, Latitude]</code> order</p>
                <div class="example">
                    Example: <code>[6.233, 0.700]</code> means the FIRST number is Longitude, SECOND is Latitude
                </div>

                <p><strong>How to know which mode to use?</strong></p>
                <ul>
                    <li>If your data comes from an ORIGIN app that stores [Lat, Long], select <strong>Origin mode</strong></li>
                    <li>If your data uses standard GeoJSON [Long, Lat] format, select <strong>Orbit mode</strong></li>
                    <li>The visualization stays accurate regardless of mode by interpreting the order correctly</li>
                </ul>

                <p><strong>What happens when you toggle?</strong></p>
                <ul>
                    <li>The coordinate numbers in your JSON will <strong>swap positions</strong></li>
                    <li>The polygon visualization will remain <strong>identical</strong></li>
                    <li>The hand rule calculation is based on the correctly interpreted geographic coordinates</li>
                </ul>

                <h3>📐 Polygon Format</h3>
                <p>Polygons must follow GeoJSON format:</p>
                <div class="example">
                    <code>{"type":"Polygon","coordinates":[[[lon1,lat1],[lon2,lat2],...,[lon1,lat1]]]}</code>
                </div>
                <p><strong>Critical:</strong> The first and last coordinates must be identical to close the polygon. This is the expected closing node and won't be flagged as a duplicate.</p>

                <h3>✅ Validation States</h3>
                <ul>
                    <li><strong>Valid:</strong> Polygon has no structural issues</li>
                    <li><strong>Self-Intersecting:</strong> Polygon edges cross each other</li>
                    <li><strong>Duplicate Nodes:</strong> Same coordinates appear multiple times (excluding the closing node pair)</li>
                    <li><strong>Blank:</strong> Empty or missing polygon data</li>
                    <li><strong>Point:</strong> Single coordinate instead of polygon</li>
                    <li><strong>Invalid JSON:</strong> Malformed JSON structure</li>
                </ul>

                <h3>🧭 Hand Rules (Rules Type)</h3>
                <p><strong>Right Hand Rule:</strong> Vertices are ordered counter-clockwise when viewed from above. Imagine walking along the edges - your right hand points outward from the polygon.</p>
                <p><strong>Left Hand Rule:</strong> Vertices are ordered clockwise when viewed from above.</p>
                <p>The tool identifies which rule your polygon follows - there's no "pass/fail", just identification.</p>

                <h3>📄 Single Polygon Mode</h3>
                <ul>
                    <li>Paste your GeoJSON polygon into the text area</li>
                    <li>Click "Validate Polygon" to see results</li>
                    <li>The map shows real-time visualization with numbered nodes</li>
                    <li>Hover over nodes on the canvas to see coordinates highlighted in the JSON display below</li>
                    <li>Toggle between Origin/Orbit mode to see coordinates swap in the JSON</li>
                    <li>Use mouse wheel to zoom in/out</li>
                    <li>Click and drag to pan around the polygon</li>
                </ul>

                <h3>📊 Bulk Upload Mode</h3>
                <ul>
                    <li>Upload CSV, XLSX, or XLS files</li>
                    <li>Required columns: <code>ID</code> (identifier) and <code>Polygon</code> (GeoJSON string)</li>
                    <li>All polygons are validated automatically</li>
                    <li>Click "MAP" button to visualize any polygon in detail</li>
                    <li>In the visualization modal, hover over nodes to highlight them on both map and list</li>
                    <li>Use mouse wheel to zoom in/out in the modal</li>
                    <li>Click and drag to pan in the modal</li>
                </ul>

                <h3>🎨 Node Colors on Map</h3>
                <ul>
                    <li><strong>🟠 Orange/Yellow:</strong> Starting node (first vertex)</li>
                    <li><strong>🔴 Red:</strong> Duplicate nodes</li>
                    <li><strong>🟢 Green (hover):</strong> Currently highlighted node</li>
                    <li><strong>🔵 Blue:</strong> Regular nodes</li>
                </ul>

                <h3>📝 Node List Indicators</h3>
                <ul>
                    <li><strong>🟠 Start:</strong> First node of the polygon</li>
                    <li><strong>⚪ End (grayed out):</strong> Last node (identical to first, closing the polygon - cannot be interacted with)</li>
                    <li><strong>🔴 Duplicate:</strong> Nodes with coordinates matching other nodes</li>
                </ul>

                <h3>💡 Tips</h3>
                <ul>
                    <li>Always ensure your first and last coordinates are identical to properly close the polygon</li>
                    <li>Use <strong>Origin mode</strong> if your data source stores coordinates as [Latitude, Longitude]</li>
                    <li>Use <strong>Orbit mode</strong> if your data source stores coordinates as [Longitude, Latitude] (standard GeoJSON)</li>
                    <li>The visualization and hand rule calculation are based on correctly interpreted geographic positions</li>
                    <li>Node numbers on the map help identify vertices in order</li>
                    <li>Bulk upload is not available on mobile devices for optimal experience</li>
                </ul>

                <h3>📏 Polygon Shape Column</h3>
                <p>This column displays the geometry type from your GeoJSON (typically "Polygon"). If the data contains a Point instead of a Polygon, it will show "Point".</p>
            </div>
        </div>
    </div>

    <script>
        let isOrbitMode = false;
        let currentMode = 'single';
        let bulkData = [];
        let currentPolygonCoords = null;
        let originalPolygonCoords = null;
        let hoveredNodeIndex = null;
        let currentCanvasId = null;

        document.getElementById('coordToggle').addEventListener('click', function() {
            this.classList.toggle('active');
            const wasOrbitMode = isOrbitMode;
            isOrbitMode = this.classList.contains('active');
            
            if (currentMode === 'single') {
                const jsonInput = document.getElementById('jsonInput');
                const jsonValue = jsonInput.value.trim();
                
                if (jsonValue) {
                    try {
                        const polygon = JSON.parse(jsonValue);
                        if (polygon.coordinates && polygon.coordinates[0]) {
                            polygon.coordinates[0] = polygon.coordinates[0].map(coord => [coord[1], coord[0]]);
                            jsonInput.value = JSON.stringify(polygon);
                            validateSingle();
                        }
                    } catch (e) {
                        // Invalid JSON, ignore
                    }
                }
            }
        });

        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                
                currentMode = this.dataset.mode;
                document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
                document.getElementById(currentMode + 'View').classList.add('active');
            });
        });

        const uploadZone = document.getElementById('uploadZone');
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            uploadZone.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        ['dragenter', 'dragover'].forEach(eventName => {
            uploadZone.addEventListener(eventName, () => uploadZone.classList.add('dragover'), false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            uploadZone.addEventListener(eventName, () => uploadZone.classList.remove('dragover'), false);
        });

        uploadZone.addEventListener('drop', handleDrop, false);

        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;
            if (files.length) {
                handleFileUpload(files[0]);
            }
        }

        function handleFile(event) {
            const file = event.target.files[0];
            if (file) handleFileUpload(file);
        }

        function handleFileUpload(file) {
            const extension = file.name.split('.').pop().toLowerCase();
            
            if (extension === 'csv') {
                Papa.parse(file, {
                    header: true,
                    skipEmptyLines: true,
                    complete: function(results) {
                        processBulkData(results.data);
                    }
                });
            } else if (extension === 'xlsx' || extension === 'xls') {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, {type: 'array'});
                    const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                    const jsonData = XLSX.utils.sheet_to_json(firstSheet);
                    processBulkData(jsonData);
                };
                reader.readAsArrayBuffer(file);
            }
        }

        function processBulkData(data) {
            bulkData = data.map((row, index) => {
                const id = row.ID || row.id || (index + 1);
                const polygonStr = row.Polygon || row.polygon || '';
                
                let result = {
                    id: id,
                    polygonStr: polygonStr,
                    states: [],
                    handRule: '',
                    polygon: null
                };

                if (!polygonStr || polygonStr.trim() === '') {
                    result.states.push({text: 'Blank', type: 'warning'});
                    return result;
                }

                try {
                    const polygon = JSON.parse(polygonStr);
                    result.polygon = polygon;
                    
                    if (!polygon.coordinates || !polygon.coordinates[0]) {
                        result.states.push({text: 'Invalid Format', type: 'error'});
                        return result;
                    }

                    const coords = polygon.coordinates[0];
                    
                    if (coords.length === 1) {
                        result.states.push({text: 'Point', type: 'warning'});
                        return result;
                    }

                    const convertedCoords = coords.map(coord => {
                        return isOrbitMode ? [coord[0], coord[1]] : [coord[1], coord[0]];
                    });

                    const validation = validatePolygon(convertedCoords);
                    result.states = validation.states;
                    result.handRule = validation.handRule;
                } catch (e) {
                    result.states.push({text: 'Invalid JSON', type: 'error'});
                }

                return result;
            });

            displayBulkResults();
        }

        function displayBulkResults() {
            const container = document.getElementById('bulkResults');
            
            if (bulkData.length === 0) {
                container.innerHTML = '<div class="empty-state"><div class="empty-state-icon">📋</div><p>No data to display</p></div>';
                return;
            }

            let html = '<table class="results-table"><thead><tr><th>ID</th><th>Polygon Shape</th><th>States</th><th>Rules Type</th><th style="width: 80px;"></th></tr></thead><tbody>';
            
            bulkData.forEach((item, index) => {
                const shape = item.polygon ? (item.polygon.type || 'Polygon') : '-';
                const statesBadges = item.states.map(s => 
                    `<span class="status-badge status-${s.type}">${s.text}</span>`
                ).join('');
                
                const handRuleBadge = item.handRule ? `<span class="status-badge status-info">${item.handRule}</span>` : '-';
                
                const canVisualize = item.polygon && item.polygon.coordinates && item.polygon.coordinates[0] && item.polygon.coordinates[0].length > 1;
                const mapBtn = canVisualize ? `<button class="map-btn" onclick="visualizePolygon(${index})">MAP</button>` : '';
                
                html += `<tr><td>${item.id}</td><td>${shape}</td><td>${statesBadges}</td><td>${handRuleBadge}</td><td>${mapBtn}</td></tr>`;
            });
            
            html += '</tbody></table>';
            container.innerHTML = html;
        }

        function validateSingle() {
            const jsonInput = document.getElementById('jsonInput').value;
            
            try {
                const polygon = JSON.parse(jsonInput);
                
                if (!polygon.coordinates || !polygon.coordinates[0]) {
                    alert('Invalid polygon format');
                    return;
                }

                const coords = polygon.coordinates[0];
                
                originalPolygonCoords = coords.map(coord => {
                    return isOrbitMode ? [coord[0], coord[1]] : [coord[1], coord[0]];
                });
                
                currentPolygonCoords = coords;
                const validation = validatePolygon(originalPolygonCoords);
                
                displaySingleResults(polygon, validation, coords.length);
                drawPolygon('singleCanvas', originalPolygonCoords);
                displayJsonWithHighlight(polygon);
            } catch (e) {
                alert('Invalid JSON: ' + e.message);
            }
        }

        function displayJsonWithHighlight(polygon) {
            const displayDiv = document.getElementById('jsonDisplay');
            const contentDiv = document.getElementById('jsonDisplayContent');
            
            displayDiv.classList.remove('hidden');
            
            let jsonStr = JSON.stringify(polygon, null, 2);
            let html = '';
            let coordIndex = 0;
            const lines = jsonStr.split('\n');
            
            for (let line of lines) {
                const coordMatch = line.match(/^(\s*)\[(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)\](.*)$/);
                if (coordMatch) {
                    const indent = coordMatch[1];
                    const coord1 = coordMatch[2];
                    const coord2 = coordMatch[3];
                    const rest = coordMatch[4];
                    
                    html += `${indent}<span class="coord-highlight" data-coord-index="${coordIndex}" onmouseenter="highlightNode(${coordIndex})" onmouseleave="unhighlightNode()">[${coord1}, ${coord2}]</span>${rest}\n`;
                    coordIndex++;
                } else {
                    html += line + '\n';
                }
            }
            
            contentDiv.innerHTML = '<pre style="margin: 0; font-family: inherit; white-space: pre-wrap; word-wrap: break-word;">' + html + '</pre>';
        }

        function displaySingleResults(polygon, validation, nodeCount) {
            const container = document.getElementById('singleResults');
            
            const statesBadges = validation.states.map(s => 
                `<span class="status-badge status-${s.type}">${s.text}</span>`
            ).join('');
            
            const handRuleBadge = validation.handRule ? `<span class="status-badge status-info">${validation.handRule}</span>` : '';
            
            let html = '<table class="results-table"><thead><tr><th>Polygon Shape</th><th>States</th><th>Rules Type</th><th>Node Count</th></tr></thead><tbody>';
            html += `<tr><td>${polygon.type || 'Polygon'}</td><td>${statesBadges}</td><td>${handRuleBadge}</td><td>${nodeCount}</td></tr>`;
            html += '</tbody></table>';
            
            container.innerHTML = html;
        }

        function validatePolygon(coords) {
            const states = [];
            let handRule = '';
            
            const duplicates = findDuplicateNodes(coords);
            if (duplicates.length > 0) {
                states.push({text: 'Duplicate Nodes', type: 'error'});
            }
            
            if (isSelfIntersecting(coords)) {
                states.push({text: 'Self-Intersecting', type: 'error'});
            }
            
            const isRightHand = checkRightHandRule(coords);
            handRule = isRightHand ? 'Left Hand Rule' : 'Right Hand Rule';
            // handRule = isRightHand ? 'Right Hand Rule' : 'Left Hand Rule';
            
            if (states.length === 0) {
                states.push({text: 'Valid', type: 'valid'});
            }
            
            return { states, handRule };
        }

        function findDuplicateNodes(coords) {
            const duplicates = [];
            const lastIndex = coords.length - 1;
            
            for (let i = 0; i < coords.length; i++) {
                for (let j = i + 1; j < coords.length; j++) {
                    if ((i === 0 && j === lastIndex) || (j === 0 && i === lastIndex)) {
                        continue;
                    }
                    
                    if (coords[i][0] === coords[j][0] && coords[i][1] === coords[j][1]) {
                        if (!duplicates.includes(i)) duplicates.push(i);
                        if (!duplicates.includes(j)) duplicates.push(j);
                    }
                }
            }
            return duplicates;
        }

        function isSelfIntersecting(coords) {
            for (let i = 0; i < coords.length - 1; i++) {
                for (let j = i + 2; j < coords.length - 1; j++) {
                    if (i === 0 && j === coords.length - 2) continue;
                    
                    if (segmentsIntersect(coords[i], coords[i + 1], coords[j], coords[j + 1])) {
                        return true;
                    }
                }
            }
            return false;
        }

        function segmentsIntersect(p1, p2, p3, p4) {
            const ccw = (A, B, C) => {
                return (C[1] - A[1]) * (B[0] - A[0]) > (B[1] - A[1]) * (C[0] - A[0]);
            };
            return ccw(p1, p3, p4) !== ccw(p2, p3, p4) && ccw(p1, p2, p3) !== ccw(p1, p2, p4);
        }

        function checkRightHandRule(coords) {
            // Use Shoelace formula for accurate signed area calculation
            let area = 0;
            for (let i = 0; i < coords.length; i++) {
                const j = (i + 1) % coords.length;
                area += coords[i][0] * coords[j][1];
                area -= coords[j][0] * coords[i][1];
            }
            area = area / 2;
            // Counter-clockwise (negative area) = Right Hand Rule
            return area < 0;
        }

        function drawPolygon(canvasId, coords) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            
            currentCanvasId = canvasId;
            
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (coords.length < 2) return;
            
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            coords.forEach(coord => {
                const x = coord[0];
                const y = coord[1];
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);
            });
            
            const padding = 60;
            const scaleX = (canvas.width - padding * 2) / (maxX - minX || 1);
            const scaleY = (canvas.height - padding * 2) / (maxY - minY || 1);
            const scale = Math.min(scaleX, scaleY);
            
            const offsetX = (canvas.width - (maxX - minX) * scale) / 2 - minX * scale;
            const offsetY = (canvas.height - (maxY - minY) * scale) / 2 - minY * scale;
            
            canvas.coordTransform = { scale, offsetX, offsetY, minX, minY, maxX, maxY };
            
            ctx.strokeStyle = '#2563eb';
            ctx.lineWidth = 2;
            ctx.fillStyle = 'rgba(37, 99, 235, 0.1)';
            
            ctx.beginPath();
            coords.forEach((coord, i) => {
                const x = coord[0];
                const y = coord[1];
                const px = x * scale + offsetX;
                const py = canvas.height - (y * scale + offsetY);
                
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            });
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            const duplicates = findDuplicateNodes(coords);
            coords.forEach((coord, i) => {
                const x = coord[0];
                const y = coord[1];
                const px = x * scale + offsetX;
                const py = canvas.height - (y * scale + offsetY);
                
                let fillColor;
                if (hoveredNodeIndex === i) {
                    fillColor = '#16a34a';
                } else if (i === 0) {
                    fillColor = '#f59e0b';
                } else if (duplicates.includes(i)) {
                    fillColor = '#ef4444';
                } else {
                    fillColor = '#2563eb';
                }
                
                ctx.beginPath();
                ctx.arc(px, py, 6, 0, Math.PI * 2);
                ctx.fillStyle = fillColor;
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.fillStyle = '#1e293b';
                ctx.font = 'bold 11px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                const numOffset = 15;
                let numX = px;
                let numY = py - numOffset;
                
                if (py < 30) numY = py + numOffset;
                
                ctx.fillStyle = 'white';
                ctx.fillRect(numX - 10, numY - 8, 20, 16);
                
                ctx.fillStyle = '#1e293b';
                ctx.fillText((i + 1).toString(), numX, numY);
            });
        }

        function visualizePolygon(index) {
            const item = bulkData[index];
            if (!item.polygon) return;
            
            const coords = item.polygon.coordinates[0];
            
            originalPolygonCoords = coords.map(coord => {
                return isOrbitMode ? [coord[0], coord[1]] : [coord[1], coord[0]];
            });
            
            currentPolygonCoords = coords;
            
            document.getElementById('modalTitle').textContent = `Polygon: ${item.id}`;
            document.getElementById('nodeCount').textContent = coords.length;
            
            setTimeout(() => {
                drawPolygon('modalCanvas', originalPolygonCoords);
            }, 100);
            
            const nodeList = document.getElementById('nodeList');
            const duplicates = findDuplicateNodes(originalPolygonCoords);
            const lastIndex = coords.length - 1;
            
            nodeList.innerHTML = coords.map((coord, i) => {
                const displayCoord1 = coord[0];
                const displayCoord2 = coord[1];
                
                const isDupe = duplicates.includes(i);
                const isStart = i === 0;
                const isEnd = i === lastIndex;
                const classes = ['node-item'];
                
                if (isEnd) {
                    classes.push('end-node');
                } else if (isDupe) {
                    classes.push('duplicate');
                } else if (isStart) {
                    classes.push('start-node');
                }
                
                let label = `<strong>Node ${i + 1}</strong>`;
                if (isStart) label += ' 🟠 Start';
                if (isEnd) label += ' ⚪ End';
                if (isDupe && !isEnd) label += ' 🔴 Duplicate';
                
                const mouseEvents = isEnd ? '' : `onmouseenter="highlightNode(${i})" onmouseleave="unhighlightNode()"`;
                
                return `<li class="${classes.join(' ')}" ${mouseEvents}>
                    ${label}
                    <div class="node-coords">${displayCoord1}, ${displayCoord2}</div>
                </li>`;
            }).join('');
            
            document.getElementById('vizModal').classList.add('active');
        }

        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('active');
            hoveredNodeIndex = null;
        }

        function highlightNode(index) {
            hoveredNodeIndex = index;
            
            document.querySelectorAll('.node-item').forEach((item, i) => {
                if (i === index) {
                    item.classList.add('active');
                } else {
                    item.classList.remove('active');
                }
            });
            
            if (currentMode === 'single') {
                document.querySelectorAll('.coord-highlight').forEach((span, i) => {
                    if (i === index) {
                        span.classList.add('active');
                    } else {
                        span.classList.remove('active');
                    }
                });
            }
            
            if (currentCanvasId && originalPolygonCoords) {
                drawPolygon(currentCanvasId, originalPolygonCoords);
            }
        }

        function unhighlightNode() {
            hoveredNodeIndex = null;
            
            document.querySelectorAll('.node-item').forEach(item => {
                item.classList.remove('active');
            });
            
            document.querySelectorAll('.coord-highlight').forEach(span => {
                span.classList.remove('active');
            });
            
            if (currentCanvasId && originalPolygonCoords) {
                drawPolygon(currentCanvasId, originalPolygonCoords);
            }
        }

        function handleCanvasHover(e, canvas, coords) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const transform = canvas.coordTransform;
            if (!transform) return;
            
            const { scale, offsetX, offsetY } = transform;
            
            let foundNode = -1;
            const threshold = 12;
            
            for (let i = 0; i < coords.length; i++) {
                const x = coords[i][0];
                const y = coords[i][1];
                const px = x * scale + offsetX;
                const py = canvas.height - (y * scale + offsetY);
                
                const dist = Math.sqrt(Math.pow(mouseX - px, 2) + Math.pow(mouseY - py, 2));
                if (dist < threshold) {
                    foundNode = i;
                    break;
                }
            }
            
            if (foundNode !== hoveredNodeIndex) {
                if (foundNode >= 0) {
                    highlightNode(foundNode);
                } else {
                    unhighlightNode();
                }
            }
        }

        function openHelp() {
            document.getElementById('helpModal').classList.add('active');
        }

        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                closeModal('vizModal');
                closeModal('helpModal');
            }
        });

        document.querySelectorAll('.modal').forEach(modal => {
            modal.addEventListener('click', function(e) {
                if (e.target === this) {
                    this.classList.remove('active');
                }
            });
        });

        window.addEventListener('resize', function() {
            if (originalPolygonCoords) {
                if (currentMode === 'single') {
                    drawPolygon('singleCanvas', originalPolygonCoords);
                } else if (document.getElementById('vizModal').classList.contains('active')) {
                    drawPolygon('modalCanvas', originalPolygonCoords);
                }
            }
        });

        const singleCanvas = document.getElementById('singleCanvas');
        
        singleCanvas.addEventListener('mousemove', function(e) {
            if (!originalPolygonCoords || currentMode !== 'single') return;
            handleCanvasHover(e, this, originalPolygonCoords);
        });
        
        singleCanvas.addEventListener('mouseleave', function() {
            if (currentMode !== 'single') return;
            unhighlightNode();
        });

        const modalCanvas = document.getElementById('modalCanvas');
        
        modalCanvas.addEventListener('mousemove', function(e) {
            if (!originalPolygonCoords) return;
            handleCanvasHover(e, this, originalPolygonCoords);
        });
        
        modalCanvas.addEventListener('mouseleave', function() {
            unhighlightNode();
        });
    </script>
</body>
<!-- Hello -->
</html> 