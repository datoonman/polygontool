<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Polygon Validator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2563eb 0%, #1e40af 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .subtitle {
            opacity: 0.9;
            font-size: 1.1em;
        }

        .controls {
            padding: 20px 30px;
            background: #f8fafc;
            border-bottom: 2px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 20px;
        }

        .toggle-group {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .toggle-label {
            font-weight: 600;
            color: #334155;
            font-size: 0.95em;
        }

        .mode-label {
            font-size: 0.85em;
            color: #64748b;
            font-weight: 500;
            position: relative;
            cursor: help;
        }

        .mode-label:hover .tooltip {
            opacity: 1;
            visibility: visible;
        }

        .tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #1e293b;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.8em;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s;
            margin-bottom: 8px;
            z-index: 100;
        }

        .tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 5px solid transparent;
            border-top-color: #1e293b;
        }

        .mode-indicator {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.75em;
            font-weight: 600;
            background: #e0e7ff;
            color: #3730a3;
        }

        .toggle-switch {
            position: relative;
            width: 60px;
            height: 30px;
            background: #cbd5e1;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .toggle-switch.active {
            background: #2563eb;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 24px;
            height: 24px;
            background: white;
            border-radius: 50%;
            top: 3px;
            left: 3px;
            transition: all 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .toggle-switch.active::after {
            left: 33px;
        }

        .mode-selector {
            display: flex;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .mode-btn {
            padding: 12px 30px;
            border: none;
            background: white;
            color: #64748b;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            font-size: 1em;
        }

        .mode-btn.active {
            background: #2563eb;
            color: white;
        }

        .mode-btn:hover:not(.active) {
            background: #f1f5f9;
        }

        .content {
            padding: 30px;
        }

        .view {
            display: none;
        }

        .view.active {
            display: block;
        }

        .single-layout {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }

        .map-container {
            width: 100%;
            height: 450px;
            background: #f8fafc;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            position: relative;
            overflow: hidden;
        }

        .coord-bubble {
            position: absolute;
            background: #1e293b;
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 0.85em;
            font-family: 'Courier New', monospace;
            pointer-events: none;
            z-index: 10;
            white-space: nowrap;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            opacity: 0;
            transition: opacity 0.2s;
            cursor: default;
        }

        .coord-bubble.active {
            opacity: 1;
        }

        .coord-bubble.locked {
            background: #2563eb;
            pointer-events: auto;
            cursor: move;
        }

        .coord-bubble.dragging {
            cursor: grabbing;
        }

        .coord-bubble::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: #1e293b;
        }

        .coord-bubble.locked::after {
            border-top-color: #2563eb;
        }

        .map-canvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        .results-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
        }

        .results-table th {
            background: #2563eb;
            color: white;
            padding: 16px;
            text-align: left;
            font-weight: 600;
            font-size: 0.9em;
        }

        .results-table td {
            padding: 16px;
            border-bottom: 1px solid #e2e8f0;
            font-size: 0.95em;
        }

        .results-table tr:last-child td {
            border-bottom: none;
        }

        .results-table tr:hover {
            background: #f8fafc;
        }

        .status-badge {
            display: inline-block;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.85em;
            font-weight: 600;
            margin: 2px;
        }

        .status-valid {
            background: #dcfce7;
            color: #166534;
        }

        .status-error {
            background: #fee2e2;
            color: #991b1b;
        }

        .status-warning {
            background: #fef3c7;
            color: #92400e;
        }

        .status-info {
            background: #dbeafe;
            color: #1e40af;
        }

        .map-btn {
            background: #2563eb;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 600;
            transition: all 0.3s;
        }

        .map-btn:hover {
            background: #1e40af;
            transform: translateY(-1px);
        }

        .json-input-container {
            position: relative;
        }

        .json-input {
            width: 100%;
            min-height: 200px;
            padding: 16px;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            resize: vertical;
            transition: all 0.3s;
            line-height: 1.6;
        }

        .json-input:focus {
            outline: none;
            border-color: #2563eb;
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        .json-display {
            margin-top: 20px;
            padding: 16px;
            background: #f8fafc;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            line-height: 1.8;
            max-height: 300px;
            overflow-y: auto;
        }

        .json-display-title {
            font-size: 1em;
            font-weight: 600;
            color: #475569;
            margin-top: 24px;
            margin-bottom: 12px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        .coord-highlight {
            cursor: pointer;
            transition: all 0.2s;
            padding: 2px 4px;
            border-radius: 3px;
        }

        .coord-highlight:hover {
            background: #dcfce7;
            color: #16a34a;
        }

        .coord-highlight.active {
            background: #dcfce7;
            color: #16a34a;
            font-weight: bold;
        }

        .btn-primary {
            background: #2563eb;
            color: white;
            border: none;
            padding: 14px 32px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 1em;
            transition: all 0.3s;
        }

        .btn-primary:hover {
            background: #1e40af;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.3);
        }

        .btn-secondary {
            background: white;
            color: #2563eb;
            border: 2px solid #2563eb;
            padding: 12px 28px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 1em;
            transition: all 0.3s;
        }

        .btn-secondary:hover {
            background: #eff6ff;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .button-group button {
            flex: 1;
            margin: 0;
        }

        .format-hint {
            background: #eff6ff;
            border: 1px solid #bfdbfe;
            border-radius: 8px;
            padding: 12px;
            margin-top: 10px;
            font-size: 0.9em;
            color: #1e40af;
        }

        .format-hint strong {
            color: #1e3a8a;
        }

        .warning-badge {
            background: #fef3c7;
            color: #92400e;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.85em;
            font-weight: 600;
            margin-top: 10px;
            display: inline-block;
        }

        .upload-zone {
            border: 3px dashed #cbd5e1;
            border-radius: 12px;
            padding: 60px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: #f8fafc;
        }

        .upload-zone:hover {
            border-color: #2563eb;
            background: #eff6ff;
        }

        .upload-zone.dragover {
            border-color: #2563eb;
            background: #dbeafe;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 1000;
            backdrop-filter: blur(4px);
        }

        .modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .modal-content {
            background: white;
            border-radius: 16px;
            width: 100%;
            max-width: 1200px;
            max-height: 90vh;
            overflow: hidden;
            box-shadow: 0 25px 50px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            padding: 24px 30px;
            background: linear-gradient(135deg, #2563eb 0%, #1e40af 100%);
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h2 {
            font-size: 1.5em;
        }

        .close-btn {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            font-size: 1.5em;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-btn:hover {
            background: rgba(255,255,255,0.3);
            transform: rotate(90deg);
        }

        .modal-body {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .modal-map {
            flex: 2;
            height: 500px;
            border-right: 2px solid #e2e8f0;
        }

        .modal-sidebar {
            flex: 1;
            padding: 24px;
            overflow-y: auto;
            background: #f8fafc;
        }

        .node-list {
            list-style: none;
        }

        .node-item {
            padding: 12px;
            margin: 8px 0;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid transparent;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .node-item:hover {
            border-color: #2563eb;
            transform: translateX(4px);
        }

        .node-item.duplicate {
            background: #fee2e2;
            border-color: #ef4444;
        }

        .node-item.start-node {
            background: #fef3c7;
            border-color: #f59e0b;
        }

        .node-item.end-node {
            background: #f1f5f9;
            border-color: #cbd5e1;
            opacity: 0.7;
            cursor: default;
        }

        .node-item.end-node:hover {
            transform: none;
        }

        .node-item.active {
            background: #dcfce7;
            border-color: #16a34a;
            transform: translateX(8px);
        }

        .node-item.end-node.active {
            transform: none;
        }

        .node-coords {
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: #64748b;
            margin-top: 4px;
        }

        .section-title {
            font-size: 1.1em;
            font-weight: 600;
            color: #1e293b;
            margin-bottom: 16px;
            padding-bottom: 8px;
            border-bottom: 2px solid #e2e8f0;
        }

        .hidden {
            display: none;
        }

        .file-input {
            display: none;
        }

        .upload-icon {
            font-size: 3em;
            color: #2563eb;
            margin-bottom: 16px;
        }

        .empty-state {
            text-align: center;
            padding: 60px;
            color: #94a3b8;
        }

        .empty-state-icon {
            font-size: 4em;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        .help-btn {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, #2563eb 0%, #1e40af 100%);
            color: white;
            border: none;
            font-size: 1.8em;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.4);
            transition: all 0.3s;
            z-index: 999;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .help-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(37, 99, 235, 0.5);
        }

        .help-content {
            max-height: 70vh;
            overflow-y: auto;
            padding: 30px;
        }

        .help-content h3 {
            color: #1e293b;
            margin-top: 24px;
            margin-bottom: 12px;
            font-size: 1.2em;
        }

        .help-content h3:first-child {
            margin-top: 0;
        }

        .help-content p, .help-content ul {
            color: #475569;
            line-height: 1.8;
            margin-bottom: 12px;
        }

        .help-content ul {
            margin-left: 20px;
        }

        .help-content li {
            margin-bottom: 8px;
        }

        .help-content code {
            background: #f1f5f9;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: #dc2626;
        }

        .help-content .example {
            background: #f8fafc;
            padding: 16px;
            border-radius: 8px;
            border-left: 4px solid #2563eb;
            margin: 16px 0;
        }

        .version-section {
            border-left: 3px solid #2563eb;
            padding-left: 16px;
            margin: 16px 0;
        }

        .version-header {
            font-weight: 600;
            color: #2563eb;
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .version-header:hover {
            color: #1e40af;
        }

        .version-badge {
            background: #2563eb;
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.85em;
        }

        .version-content {
            margin-top: 8px;
        }

        .version-content.collapsed {
            display: none;
        }

        .version-item {
            margin: 6px 0;
            color: #475569;
        }

        .show-more-btn {
            background: #eff6ff;
            color: #2563eb;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            margin: 16px 0;
        }

        .show-more-btn:hover {
            background: #dbeafe;
        }

        @media (max-width: 1024px) {
            .single-layout {
                grid-template-columns: 1fr;
            }
            
            .modal-body {
                flex-direction: column;
            }
            
            .modal-map {
                border-right: none;
                border-bottom: 2px solid #e2e8f0;
                height: 300px;
            }
            
            .modal-sidebar {
                max-height: 300px;
            }
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            h1 {
                font-size: 1.8em;
            }
            
            .controls {
                padding: 15px 20px;
            }
            
            .content {
                padding: 20px;
            }
            
            .mode-selector {
                width: 100%;
            }
            
            .mode-btn {
                flex: 1;
                padding: 10px 15px;
                font-size: 0.9em;
            }
            
            .mode-btn.bulk-mode {
                display: none;
            }
            
            .map-container {
                height: 300px;
            }
            
            .help-btn {
                width: 50px;
                height: 50px;
                font-size: 1.5em;
                bottom: 20px;
                right: 20px;
            }
            
            .results-table {
                font-size: 0.85em;
            }
            
            .results-table th,
            .results-table td {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🗺️ Polygon Validator</h1>
            <p class="subtitle">Validate and visualize polygon geometries</p>
        </div>

        <div class="controls">
            <div class="toggle-group">
                <span class="toggle-label">Coordinate Mode:</span>
                <span class="mode-label">
                    Origin (Lat, Long)
                    <span class="tooltip">Coordinates are [Latitude, Longitude]</span>
                </span>
                <div class="toggle-switch" id="coordToggle"></div>
                <span class="mode-label">
                    Orbit (Long, Lat)
                    <span class="tooltip">Coordinates are [Longitude, Latitude]</span>
                </span>
                <span class="mode-indicator" id="modeIndicator">Origin Mode</span>
            </div>

            <div class="mode-selector">
                <button class="mode-btn active" data-mode="single">Single Polygon</button>
                <button class="mode-btn bulk-mode" data-mode="bulk">Bulk Upload</button>
            </div>
        </div>

        <div class="content">
            <div class="view active" id="singleView">
                <div class="single-layout">
                    <div>
                        <h3 style="margin-bottom: 12px; color: #1e293b;">Visualization</h3>
                        <div class="map-container" id="mapContainer">
                            <canvas class="map-canvas" id="singleCanvas"></canvas>
                            <div class="coord-bubble" id="coordBubble"></div>
                        </div>
                        <div id="singleResults"></div>
                    </div>
                    
                    <div>
                        <h3 style="margin-bottom: 12px; color: #1e293b;">Paste Polygon JSON</h3>
                        <div class="json-input-container">
                            <textarea class="json-input" id="jsonInput" placeholder='{"type":"Polygon","coordinates":[[[6.233,0.700],...]]]}'></textarea>
                        </div>
                        <div class="format-hint" id="formatHint">
                            <strong>Expected format:</strong> <span id="formatHintText">[Latitude, Longitude]</span>
                        </div>
                        <div class="button-group">
                            <button class="btn-primary" onclick="validateSingle()">Validate Polygon</button>
                            <button class="btn-secondary" onclick="autoClosePolygon()">Auto-Close</button>
                            <button class="btn-secondary" onclick="clearSingle()">Clear</button>
                        </div>
                        
                        <div id="jsonDisplay" class="hidden">
                            <div class="json-display-title">Polygon Summary:</div>
                            <div class="json-display" id="jsonDisplayContent"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="view" id="bulkView">
                <div class="upload-zone" id="uploadZone" onclick="document.getElementById('fileInput').click()">
                    <div class="upload-icon">📁</div>
                    <h3>Drop your file here or click to browse</h3>
                    <p style="color: #64748b; margin-top: 8px;">Supports CSV, XLSX, XLS</p>
                    <p style="color: #64748b; margin-top: 4px; font-size: 0.9em;">Required columns: <code>ID</code> and <code>Polygon</code></p>
                    <input type="file" id="fileInput" class="file-input" accept=".csv,.xlsx,.xls" onchange="handleFile(event)">
                </div>

                <div id="bulkResults"></div>
            </div>
        </div>
    </div>

    <button class="help-btn" onclick="openHelp()">?</button>

    <div class="modal" id="vizModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modalTitle">Polygon Visualization</h2>
                <button class="close-btn" onclick="closeModal('vizModal')">×</button>
            </div>
            <div class="modal-body">
                <div class="modal-map">
                    <canvas class="map-canvas" id="modalCanvas"></canvas>
                </div>
                <div class="modal-sidebar">
                    <div class="section-title">Nodes (<span id="nodeCount">0</span>)</div>
                    <ul class="node-list" id="nodeList"></ul>
                </div>
            </div>
        </div>
    </div>

    <div class="modal" id="helpModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>📚 User Guide</h2>
                <button class="close-btn" onclick="closeModal('helpModal')">×</button>
            </div>
            <div class="help-content">
                <h3>🎯 Overview</h3>
                <p>This tool validates polygon geometries and checks for common issues like self-intersection, duplicate nodes, and winding direction.</p>

                <h3>🔄 Coordinate Modes Explained</h3>
                <p><strong>IMPORTANT:</strong> The coordinate mode tells the tool how to interpret the order of numbers in your JSON coordinates.</p>
                
                <p><strong>Origin Mode (Lat, Long)</strong>: Your JSON has coordinates in <code>[Latitude, Longitude]</code> order</p>
                <div class="example">
                    Example: <code>[0.700, 6.233]</code> means the FIRST number is Latitude, SECOND is Longitude
                </div>
                
                <p><strong>Orbit Mode (Long, Lat)</strong>: Your JSON has coordinates in <code>[Longitude, Latitude]</code> order</p>
                <div class="example">
                    Example: <code>[6.233, 0.700]</code> means the FIRST number is Longitude, SECOND is Latitude
                </div>

                <p><strong>How to know which mode to use?</strong></p>
                <ul>
                    <li>If your data comes from an ORIGIN app that stores [Lat, Long], select <strong>Origin mode</strong></li>
                    <li>If your data uses standard GeoJSON [Long, Lat] format, select <strong>Orbit mode</strong></li>
                    <li>The visualization stays accurate regardless of mode by interpreting the order correctly</li>
                </ul>

                <p><strong>What happens when you toggle?</strong></p>
                <ul>
                    <li>The coordinate numbers in your JSON will <strong>swap positions</strong></li>
                    <li>The polygon visualization will remain <strong>identical</strong></li>
                    <li>The hand rule calculation is based on the correctly interpreted geographic coordinates</li>
                </ul>

                <h3>📐 Polygon Format</h3>
                <p>Polygons must follow GeoJSON format:</p>
                <div class="example">
                    <code>{"type":"Polygon","coordinates":[[[lon1,lat1],[lon2,lat2],...,[lon1,lat1]]]}</code>
                </div>
                <p><strong>Critical:</strong> The first and last coordinates must be identical to close the polygon. This is the expected closing node and won't be flagged as a duplicate.</p>

                <h3>✅ Validation States</h3>
                <ul>
                    <li><strong>Valid:</strong> Polygon has no structural issues</li>
                    <li><strong>Self-Intersecting:</strong> Polygon edges cross each other</li>
                    <li><strong>Duplicate Nodes:</strong> Same coordinates appear multiple times (excluding the closing node pair)</li>
                    <li><strong>Blank:</strong> Empty or missing polygon data</li>
                    <li><strong>Point:</strong> Single coordinate instead of polygon</li>
                    <li><strong>Invalid JSON:</strong> Malformed JSON structure</li>
                </ul>

                <h3>🧭 Hand Rules (Rules Type)</h3>
                <p><strong>Right Hand Rule:</strong> Vertices are ordered counter-clockwise when viewed from above. Imagine walking along the edges - your right hand points outward from the polygon.</p>
                <p><strong>Left Hand Rule:</strong> Vertices are ordered clockwise when viewed from above.</p>
                <p>The tool identifies which rule your polygon follows - there's no "pass/fail", just identification.</p>

                <h3>📄 Single Polygon Mode</h3>
                <ul>
                    <li>Paste your GeoJSON polygon into the text area</li>
                    <li>Click "Validate Polygon" to see results</li>
                    <li>The map shows real-time visualization with numbered nodes</li>
                    <li>Hover over nodes on the canvas to see coordinates highlighted in the JSON display below</li>
                    <li>Toggle between Origin/Orbit mode to see coordinates swap in the JSON</li>
                    <li>Use mouse wheel to zoom in/out</li>
                    <li>Click and drag to pan around the polygon</li>
                </ul>

                <h3>📊 Bulk Upload Mode</h3>
                <ul>
                    <li>Upload CSV, XLSX, or XLS files</li>
                    <li>Required columns: <code>ID</code> (identifier) and <code>Polygon</code> (GeoJSON string)</li>
                    <li>All polygons are validated automatically</li>
                    <li>Click "MAP" button to visualize any polygon in detail</li>
                    <li>In the visualization modal, hover over nodes to highlight them on both map and list</li>
                    <li>Use mouse wheel to zoom in/out in the modal</li>
                    <li>Click and drag to pan in the modal</li>
                </ul>

                <h3>🎨 Node Colors on Map</h3>
                <ul>
                    <li><strong>🟠 Orange/Yellow:</strong> Starting node (first vertex)</li>
                    <li><strong>🔴 Red:</strong> Duplicate nodes</li>
                    <li><strong>🟢 Green (hover):</strong> Currently highlighted node</li>
                    <li><strong>🔵 Blue:</strong> Regular nodes</li>
                </ul>

                <h3>📝 Node List Indicators</h3>
                <ul>
                    <li><strong>🟠 Start:</strong> First node of the polygon</li>
                    <li><strong>⚪ End (grayed out):</strong> Last node (identical to first, closing the polygon - cannot be interacted with)</li>
                    <li><strong>🔴 Duplicate:</strong> Nodes with coordinates matching other nodes</li>
                </ul>

                <h3>💡 Tips</h3>
                <ul>
                    <li>Always ensure your first and last coordinates are identical to properly close the polygon</li>
                    <li>Use <strong>Origin mode</strong> if your data source stores coordinates as [Latitude, Longitude]</li>
                    <li>Use <strong>Orbit mode</strong> if your data source stores coordinates as [Longitude, Latitude] (standard GeoJSON)</li>
                    <li>The visualization and hand rule calculation are based on correctly interpreted geographic positions</li>
                    <li>Node numbers on the map help identify vertices in order</li>
                    <li>Bulk upload is not available on mobile devices for optimal experience</li>
                </ul>

                <h3>📏 Polygon Shape Column</h3>
                <p>This column displays the geometry type from your GeoJSON (typically "Polygon"). If the data contains a Point instead of a Polygon, it will show "Point".</p>

                <h3>🔧 Version History & Patch Notes</h3>
                
                <div class="version-section">
                    <div class="version-header" onclick="toggleVersion('v29')">
                        <span class="version-badge">v29</span>
                        <span>Latest - Map Pan & Smooth Zoom</span>
                        <span id="v29-arrow">▼</span>
                    </div>
                    <div class="version-content" id="v29-content">
                        <div class="version-item">• Added smooth zoom functionality (mouse wheel) with gentle increments</div>
                        <div class="version-item">• Added map panning - drag anywhere on canvas to reposition view</div>
                        <div class="version-item">• Locked coordinate bubbles stay in place while panning</div>
                        <div class="version-item">• Auto-hide node labels for large polygons (100+ nodes) when zoomed out</div>
                        <div class="version-item">• Smaller node size for dense polygons (100+)</div>
                        <div class="version-item">• Warning message for large polygons</div>
                        <div class="version-item">• Improved Polygon Summary spacing</div>
                    </div>
                </div>

                <div class="version-section">
                    <div class="version-header" onclick="toggleVersion('v28')">
                        <span class="version-badge">v28</span>
                        <span>Draggable Bubbles & Auto-Close</span>
                        <span id="v28-arrow">▼</span>
                    </div>
                    <div class="version-content collapsed" id="v28-content">
                        <div class="version-item">• Added draggable coordinate bubbles when locked</div>
                        <div class="version-item">• Added "Auto-Close" button to complete unclosed polygons</div>
                        <div class="version-item">• Improved button sizing consistency</div>
                    </div>
                </div>

                <div class="version-section">
                    <div class="version-header" onclick="toggleVersion('v27')">
                        <span class="version-badge">v27</span>
                        <span>Coordinate Bubbles & Polygon Summary</span>
                        <span id="v27-arrow">▼</span>
                    </div>
                    <div class="version-content collapsed" id="v27-content">
                        <div class="version-item">• Added hover bubble showing coordinate details on nodes</div>
                        <div class="version-item">• Click to lock/unlock coordinate bubble</div>
                        <div class="version-item">• Replaced JSON display with useful Polygon Summary</div>
                        <div class="version-item">• Added center point and bounding box calculations</div>
                        <div class="version-item">• Added "Clear" button</div>
                    </div>
                </div>

                <button class="show-more-btn" id="showMoreBtn" onclick="toggleOlderVersions()">Show 3 Earlier Versions</button>

                <div id="olderVersions" style="display: none;">
                    <div class="version-section">
                        <div class="version-header" onclick="toggleVersion('v26')">
                            <span class="version-badge">v26</span>
                            <span>UI Improvements & Tooltips</span>
                            <span id="v26-arrow">▼</span>
                        </div>
                        <div class="version-content collapsed" id="v26-content">
                            <div class="version-item">• Added mode indicator badge</div>
                            <div class="version-item">• Added tooltips for Origin/Orbit modes</div>
                            <div class="version-item">• Added format hints for expected coordinate order</div>
                            <div class="version-item">• Improved validation with polygon closure check</div>
                            <div class="version-item">• Added minimum node count validation</div>
                        </div>
                    </div>

                    <div class="version-section">
                        <div class="version-header" onclick="toggleVersion('v25')">
                            <span class="version-badge">v25</span>
                            <span>Hand Rule & Point Detection Fixes</span>
                            <span id="v25-arrow">▼</span>
                        </div>
                        <div class="version-content collapsed" id="v25-content">
                            <div class="version-item">• Fixed Right Hand Rule calculation using Shoelace formula</div>
                            <div class="version-item">• Corrected Point geometry detection</div>
                            <div class="version-item">• Fixed node count to exclude closing duplicate</div>
                            <div class="version-item">• Fixed first node rendering (now draws on top in orange)</div>
                        </div>
                    </div>

                    <div class="version-section">
                        <div class="version-header" onclick="toggleVersion('v24')">
                            <span class="version-badge">v24</span>
                            <span>Initial Release</span>
                            <span id="v24-arrow">▼</span>
                        </div>
                        <div class="version-content collapsed" id="v24-content">
                            <div class="version-item">• Single polygon validation</div>
                            <div class="version-item">• Bulk upload (CSV, Excel)</div>
                            <div class="version-item">• Origin/Orbit coordinate mode switching</div>
                            <div class="version-item">• Visual polygon rendering with numbered nodes</div>
                            <div class="version-item">• Validation: self-intersection, duplicates, hand rule</div>
                            <div class="version-item">• Mobile-responsive design</div>
                        </div>
                    </div>
                </div>

                <script>
                    function toggleVersion(versionId) {
                        const content = document.getElementById(versionId + '-content');
                        const arrow = document.getElementById(versionId + '-arrow');
                        content.classList.toggle('collapsed');
                        arrow.textContent = content.classList.contains('collapsed') ? '▶' : '▼';
                    }

                    function toggleOlderVersions() {
                        const olderVersions = document.getElementById('olderVersions');
                        const btn = document.getElementById('showMoreBtn');
                        if (olderVersions.style.display === 'none') {
                            olderVersions.style.display = 'block';
                            btn.textContent = 'Hide Earlier Versions';
                        } else {
                            olderVersions.style.display = 'none';
                            btn.textContent = 'Show 3 Earlier Versions';
                        }
                    }
                </script>
            </div>
        </div>
    </div>

    <script>
        let isOrbitMode = false;
        let currentMode = 'single';
        let bulkData = [];
        let currentPolygonCoords = null;
        let originalPolygonCoords = null;
        let hoveredNodeIndex = null;
        let currentCanvasId = null;
        let lockedNodeIndex = null;
        let isDraggingBubble = false;
        let bubbleDragStartX = 0;
        let bubbleDragStartY = 0;
        let bubbleOffsetX = 0;
        let bubbleOffsetY = 0;
        
        // Map panning and zooming
        let zoomLevel = 1;
        let panOffsetX = 0;
        let panOffsetY = 0;
        let isDraggingMap = false;
        let mapDragStartX = 0;
        let mapDragStartY = 0;

        document.getElementById('coordToggle').addEventListener('click', function() {
            this.classList.toggle('active');
            const wasOrbitMode = isOrbitMode;
            isOrbitMode = this.classList.contains('active');
            
            // Update mode indicator
            document.getElementById('modeIndicator').textContent = isOrbitMode ? 'Orbit Mode' : 'Origin Mode';
            document.getElementById('formatHintText').textContent = isOrbitMode ? '[Longitude, Latitude]' : '[Latitude, Longitude]';
            
            if (currentMode === 'single') {
                const jsonInput = document.getElementById('jsonInput');
                const jsonValue = jsonInput.value.trim();
                
                if (jsonValue) {
                    try {
                        const polygon = JSON.parse(jsonValue);
                        // Don't swap if it's a Point
                        if (polygon.type === 'Point') {
                            return;
                        }
                        if (polygon.coordinates && polygon.coordinates[0]) {
                            polygon.coordinates[0] = polygon.coordinates[0].map(coord => [coord[1], coord[0]]);
                            jsonInput.value = JSON.stringify(polygon);
                            validateSingle();
                        }
                    } catch (e) {
                        // Invalid JSON, ignore
                    }
                }
            }
        });

        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                
                currentMode = this.dataset.mode;
                document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
                document.getElementById(currentMode + 'View').classList.add('active');
            });
        });

        const uploadZone = document.getElementById('uploadZone');
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            uploadZone.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        ['dragenter', 'dragover'].forEach(eventName => {
            uploadZone.addEventListener(eventName, () => uploadZone.classList.add('dragover'), false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            uploadZone.addEventListener(eventName, () => uploadZone.classList.remove('dragover'), false);
        });

        uploadZone.addEventListener('drop', handleDrop, false);

        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;
            if (files.length) {
                handleFileUpload(files[0]);
            }
        }

        function handleFile(event) {
            const file = event.target.files[0];
            if (file) handleFileUpload(file);
        }

        function handleFileUpload(file) {
            const extension = file.name.split('.').pop().toLowerCase();
            
            if (extension === 'csv') {
                Papa.parse(file, {
                    header: true,
                    skipEmptyLines: true,
                    complete: function(results) {
                        processBulkData(results.data);
                    }
                });
            } else if (extension === 'xlsx' || extension === 'xls') {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, {type: 'array'});
                    const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                    const jsonData = XLSX.utils.sheet_to_json(firstSheet);
                    processBulkData(jsonData);
                };
                reader.readAsArrayBuffer(file);
            }
        }

        function processBulkData(data) {
            bulkData = data.map((row, index) => {
                const id = row.ID || row.id || (index + 1);
                const polygonStr = row.Polygon || row.polygon || '';
                
                let result = {
                    id: id,
                    polygonStr: polygonStr,
                    states: [],
                    handRule: '',
                    polygon: null
                };

                if (!polygonStr || polygonStr.trim() === '') {
                    result.states.push({text: 'Blank', type: 'warning'});
                    return result;
                }

                try {
                    const polygon = JSON.parse(polygonStr);
                    result.polygon = polygon;
                    
                    // Check if it's a Point type
                    if (polygon.type === 'Point') {
                        result.states.push({text: 'Point', type: 'warning'});
                        return result;
                    }
                    
                    if (!polygon.coordinates || !polygon.coordinates[0]) {
                        result.states.push({text: 'Invalid Format', type: 'error'});
                        return result;
                    }

                    const coords = polygon.coordinates[0];
                    
                    if (coords.length < 1) {
                        result.states.push({text: 'No Coordinates', type: 'error'});
                        return result;
                    }

                    // Origin mode: input is [Lat, Long], swap to [Long, Lat] for calculation
                    // Orbit mode: input is [Long, Lat], use as-is
                    const convertedCoords = coords.map(coord => {
                        return isOrbitMode ? [coord[0], coord[1]] : [coord[1], coord[0]];
                    });

                    const validation = validatePolygon(convertedCoords);
                    result.states = validation.states;
                    result.handRule = validation.handRule;
                } catch (e) {
                    result.states.push({text: 'Invalid JSON', type: 'error'});
                }

                return result;
            });

            displayBulkResults();
        }

        function displayBulkResults() {
            const container = document.getElementById('bulkResults');
            
            if (bulkData.length === 0) {
                container.innerHTML = '<div class="empty-state"><div class="empty-state-icon">📋</div><p>No data to display</p></div>';
                return;
            }

            let html = '<table class="results-table"><thead><tr><th>ID</th><th>Polygon Shape</th><th>States</th><th>Rules Type</th><th style="width: 80px;"></th></tr></thead><tbody>';
            
            bulkData.forEach((item, index) => {
                const shape = item.polygon ? (item.polygon.type || 'Polygon') : '-';
                const statesBadges = item.states.map(s => 
                    `<span class="status-badge status-${s.type}">${s.text}</span>`
                ).join('');
                
                const handRuleBadge = item.handRule ? `<span class="status-badge status-info">${item.handRule}</span>` : '-';
                
                const canVisualize = item.polygon && item.polygon.coordinates && item.polygon.coordinates[0] && item.polygon.coordinates[0].length > 1;
                const mapBtn = canVisualize ? `<button class="map-btn" onclick="visualizePolygon(${index})">MAP</button>` : '';
                
                html += `<tr><td>${item.id}</td><td>${shape}</td><td>${statesBadges}</td><td>${handRuleBadge}</td><td>${mapBtn}</td></tr>`;
            });
            
            html += '</tbody></table>';
            container.innerHTML = html;
        }

        function validateSingle() {
            const jsonInput = document.getElementById('jsonInput').value;
            
            try {
                const polygon = JSON.parse(jsonInput);
                
                // Check if it's a Point type FIRST before accessing coordinates[0]
                if (polygon.type === 'Point') {
                    displaySingleResults(polygon, {states: [{text: 'Point', type: 'warning'}], handRule: ''}, 1);
                    
                    const canvas = document.getElementById('singleCanvas');
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    document.getElementById('jsonDisplay').classList.remove('hidden');
                    document.getElementById('jsonDisplayContent').innerHTML = '<pre style="margin: 0; font-family: inherit;">' + JSON.stringify(polygon, null, 2) + '</pre>';
                    return;
                }
                
                if (!polygon.coordinates || !polygon.coordinates[0]) {
                    alert('Invalid polygon format');
                    return;
                }

                const coords = polygon.coordinates[0];
                
                // Origin mode: input is [Lat, Long], swap to [Long, Lat] for calculation
                // Orbit mode: input is [Long, Lat], use as-is
                originalPolygonCoords = coords.map(coord => {
                    return isOrbitMode ? [coord[0], coord[1]] : [coord[1], coord[0]];
                });
                
                currentPolygonCoords = coords;
                const validation = validatePolygon(originalPolygonCoords);
                
                displaySingleResults(polygon, validation, coords.length);
                
                // Reset zoom and pan
                zoomLevel = 1;
                panOffsetX = 0;
                panOffsetY = 0;
                
                drawPolygon('singleCanvas', originalPolygonCoords);
                displayJsonWithHighlight(polygon);
            } catch (e) {
                alert('Invalid JSON: ' + e.message);
            }
        }

        function displayJsonWithHighlight(polygon) {
            const displayDiv = document.getElementById('jsonDisplay');
            const contentDiv = document.getElementById('jsonDisplayContent');
            
            displayDiv.classList.remove('hidden');
            
            if (!originalPolygonCoords || originalPolygonCoords.length === 0) {
                contentDiv.innerHTML = '<p>No polygon data available</p>';
                return;
            }
            
            const coords = polygon.coordinates[0];
            const actualNodeCount = coords.length - 1; // Exclude closing node
            const duplicates = findDuplicateNodes(originalPolygonCoords);
            
            // Calculate bounding box
            let minLat = Infinity, maxLat = -Infinity, minLon = Infinity, maxLon = -Infinity;
            originalPolygonCoords.forEach(coord => {
                const lon = coord[0];
                const lat = coord[1];
                minLon = Math.min(minLon, lon);
                maxLon = Math.max(maxLon, lon);
                minLat = Math.min(minLat, lat);
                maxLat = Math.max(maxLat, lat);
            });
            
            const centerLon = (minLon + maxLon) / 2;
            const centerLat = (minLat + maxLat) / 2;
            
            let html = `
                <div style="font-family: -apple-system, sans-serif; line-height: 1.8;">
                    <p style="margin: 8px 0;"><strong>Unique Nodes:</strong> ${actualNodeCount}</p>
                    <p style="margin: 8px 0;"><strong>Total Coordinates:</strong> ${coords.length} (including closing node)</p>
                    <p style="margin: 8px 0;"><strong>Duplicate Nodes:</strong> ${duplicates.length > 0 ? duplicates.length + ' found' : 'None'}</p>
                    <p style="margin: 8px 0;"><strong>Center Point:</strong> [${centerLon.toFixed(6)}, ${centerLat.toFixed(6)}]</p>
                    <p style="margin: 8px 0;"><strong>Bounding Box:</strong></p>
                    <ul style="margin-left: 20px; margin-top: 4px;">
                        <li style="margin: 4px 0;">Longitude: ${minLon.toFixed(6)} to ${maxLon.toFixed(6)}</li>
                        <li style="margin: 4px 0;">Latitude: ${minLat.toFixed(6)} to ${maxLat.toFixed(6)}</li>
                    </ul>
                </div>
            `;
            
            contentDiv.innerHTML = html;
        }

        function clearSingle() {
            document.getElementById('jsonInput').value = '';
            document.getElementById('singleResults').innerHTML = '';
            document.getElementById('jsonDisplay').classList.add('hidden');
            
            const canvas = document.getElementById('singleCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            originalPolygonCoords = null;
            currentPolygonCoords = null;
            hoveredNodeIndex = null;
            lockedNodeIndex = null;
            zoomLevel = 1;
            panOffsetX = 0;
            panOffsetY = 0;
            hideCoordBubble();
        }

        function displaySingleResults(polygon, validation, nodeCount) {
            const container = document.getElementById('singleResults');
            
            const statesBadges = validation.states.map(s => 
                `<span class="status-badge status-${s.type}">${s.text}</span>`
            ).join('');
            
            const handRuleBadge = validation.handRule ? `<span class="status-badge status-info">${validation.handRule}</span>` : '';
            
            // Don't subtract for Point type, but subtract for Polygon type
            const actualNodeCount = polygon.type === 'Point' ? nodeCount : (nodeCount > 0 ? nodeCount - 1 : nodeCount);
            
            let html = '<table class="results-table"><thead><tr><th>Polygon Shape</th><th>States</th><th>Rules Type</th><th>Node Count</th></tr></thead><tbody>';
            html += `<tr><td>${polygon.type || 'Polygon'}</td><td>${statesBadges}</td><td>${handRuleBadge}</td><td>${actualNodeCount}</td></tr>`;
            html += '</tbody></table>';
            
            container.innerHTML = html;
        }

        function validatePolygon(coords) {
            const states = [];
            let handRule = '';
            
            // Check if polygon is properly closed
            const firstCoord = coords[0];
            const lastCoord = coords[coords.length - 1];
            if (firstCoord[0] !== lastCoord[0] || firstCoord[1] !== lastCoord[1]) {
                states.push({text: 'Not Closed (First ≠ Last)', type: 'error'});
            }
            
            // Check minimum nodes
            if (coords.length < 4) {
                states.push({text: 'Insufficient Nodes (needs ≥4)', type: 'error'});
            }
            
            const duplicates = findDuplicateNodes(coords);
            if (duplicates.length > 0) {
                states.push({text: 'Duplicate Nodes', type: 'error'});
            }
            
            if (isSelfIntersecting(coords)) {
                states.push({text: 'Self-Intersecting', type: 'error'});
            }
            
            const isRightHand = checkRightHandRule(coords);
            handRule = isRightHand ? 'Right Hand Rule' : 'Left Hand Rule';
            
            if (states.length === 0) {
                states.push({text: 'Valid', type: 'valid'});
            }
            
            return { states, handRule };
        }

        function findDuplicateNodes(coords) {
            const duplicates = [];
            const lastIndex = coords.length - 1;
            
            for (let i = 0; i < coords.length; i++) {
                for (let j = i + 1; j < coords.length; j++) {
                    if ((i === 0 && j === lastIndex) || (j === 0 && i === lastIndex)) {
                        continue;
                    }
                    
                    if (coords[i][0] === coords[j][0] && coords[i][1] === coords[j][1]) {
                        if (!duplicates.includes(i)) duplicates.push(i);
                        if (!duplicates.includes(j)) duplicates.push(j);
                    }
                }
            }
            return duplicates;
        }

        function isSelfIntersecting(coords) {
            for (let i = 0; i < coords.length - 1; i++) {
                for (let j = i + 2; j < coords.length - 1; j++) {
                    if (i === 0 && j === coords.length - 2) continue;
                    
                    if (segmentsIntersect(coords[i], coords[i + 1], coords[j], coords[j + 1])) {
                        return true;
                    }
                }
            }
            return false;
        }

        function segmentsIntersect(p1, p2, p3, p4) {
            const ccw = (A, B, C) => {
                return (C[1] - A[1]) * (B[0] - A[0]) > (B[1] - A[1]) * (C[0] - A[0]);
            };
            return ccw(p1, p3, p4) !== ccw(p2, p3, p4) && ccw(p1, p2, p3) !== ccw(p1, p2, p4);
        }

        function checkRightHandRule(coords) {
            // Use Shoelace formula for accurate signed area calculation
            let area = 0;
            for (let i = 0; i < coords.length; i++) {
                const j = (i + 1) % coords.length;
                area += coords[i][0] * coords[j][1];
                area -= coords[j][0] * coords[i][1];
            }
            area = area / 2;
            // FLIPPED LOGIC: Positive area = Right Hand Rule, Negative = Left Hand Rule
            return area > 0;
        }

        function drawPolygon(canvasId, coords) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            
            currentCanvasId = canvasId;
            
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (coords.length < 2) return;
            
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            coords.forEach(coord => {
                const x = coord[0];
                const y = coord[1];
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);
            });
            
            const padding = 60;
            const baseScaleX = (canvas.width - padding * 2) / (maxX - minX || 1);
            const baseScaleY = (canvas.height - padding * 2) / (maxY - minY || 1);
            const baseScale = Math.min(baseScaleX, baseScaleY);
            
            // No zoom for now, just use base scale
            const scale = baseScale;
            
            // Apply pan offset
            const baseOffsetX = (canvas.width - (maxX - minX) * baseScale) / 2 - minX * baseScale;
            const baseOffsetY = (canvas.height - (maxY - minY) * baseScale) / 2 - minY * baseScale;
            
            const offsetX = baseOffsetX + panOffsetX;
            const offsetY = baseOffsetY + panOffsetY;
            
            canvas.coordTransform = { scale, offsetX, offsetY, minX, minY, maxX, maxY };
            
            ctx.strokeStyle = '#2563eb';
            ctx.lineWidth = 2;
            ctx.fillStyle = 'rgba(37, 99, 235, 0.1)';
            
            ctx.beginPath();
            coords.forEach((coord, i) => {
                const x = coord[0];
                const y = coord[1];
                const px = x * scale + offsetX;
                const py = canvas.height - (y * scale + offsetY);
                
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            });
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Always show labels, adjust size for large polygons
            const nodeSize = coords.length > 100 ? 4 : 6;
            
            const duplicates = findDuplicateNodes(coords);
            
            // Draw all nodes except the first one
            coords.forEach((coord, i) => {
                if (i === 0) return;
                
                const x = coord[0];
                const y = coord[1];
                const px = x * scale + offsetX;
                const py = canvas.height - (y * scale + offsetY);
                
                let fillColor;
                if (hoveredNodeIndex === i) {
                    fillColor = '#16a34a';
                } else if (duplicates.includes(i)) {
                    fillColor = '#ef4444';
                } else {
                    fillColor = '#2563eb';
                }
                
                ctx.beginPath();
                ctx.arc(px, py, nodeSize, 0, Math.PI * 2);
                ctx.fillStyle = fillColor;
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.fillStyle = '#1e293b';
                ctx.font = 'bold 11px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                const numOffset = 15;
                let numX = px;
                let numY = py - numOffset;
                
                if (py < 30) numY = py + numOffset;
                
                ctx.fillStyle = 'white';
                ctx.fillRect(numX - 10, numY - 8, 20, 16);
                
                ctx.fillStyle = '#1e293b';
                ctx.fillText((i + 1).toString(), numX, numY);
            });
            
            // Draw the first node last so it's on top (orange)
            const firstCoord = coords[0];
            const x0 = firstCoord[0];
            const y0 = firstCoord[1];
            const px0 = x0 * scale + offsetX;
            const py0 = canvas.height - (y0 * scale + offsetY);
            
            ctx.beginPath();
            ctx.arc(px0, py0, nodeSize, 0, Math.PI * 2);
            ctx.fillStyle = hoveredNodeIndex === 0 ? '#16a34a' : '#f59e0b';
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.fillStyle = '#1e293b';
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const numOffset0 = 15;
            let numX0 = px0;
            let numY0 = py0 - numOffset0;
            
            if (py0 < 30) numY0 = py0 + numOffset0;
            
            ctx.fillStyle = 'white';
            ctx.fillRect(numX0 - 10, numY0 - 8, 20, 16);
            
            ctx.fillStyle = '#1e293b';
            ctx.fillText('1', numX0, numY0);
        }

        function visualizePolygon(index) {
            const item = bulkData[index];
            if (!item.polygon) return;
            
            const coords = item.polygon.coordinates[0];
            
            // Origin mode: input is [Lat, Long], swap to [Long, Lat] for calculation
            // Orbit mode: input is [Long, Lat], use as-is
            originalPolygonCoords = coords.map(coord => {
                return isOrbitMode ? [coord[0], coord[1]] : [coord[1], coord[0]];
            });
            
            currentPolygonCoords = coords;
            
            document.getElementById('modalTitle').textContent = `Polygon: ${item.id}`;
            const actualNodeCount = coords.length - 1; // Exclude closing node
            document.getElementById('nodeCount').textContent = actualNodeCount;
            
            setTimeout(() => {
                drawPolygon('modalCanvas', originalPolygonCoords);
            }, 100);
            
            const nodeList = document.getElementById('nodeList');
            const duplicates = findDuplicateNodes(originalPolygonCoords);
            const lastIndex = coords.length - 1;
            
            nodeList.innerHTML = coords.map((coord, i) => {
                const displayCoord1 = coord[0];
                const displayCoord2 = coord[1];
                
                const isDupe = duplicates.includes(i);
                const isStart = i === 0;
                const isEnd = i === lastIndex;
                const classes = ['node-item'];
                
                if (isEnd) {
                    classes.push('end-node');
                } else if (isDupe) {
                    classes.push('duplicate');
                } else if (isStart) {
                    classes.push('start-node');
                }
                
                let label = `<strong>Node ${i + 1}</strong>`;
                if (isStart) label += ' 🟠 Start';
                if (isEnd) label += ' ⚪ End';
                if (isDupe && !isEnd) label += ' 🔴 Duplicate';
                
                const mouseEvents = isEnd ? '' : `onmouseenter="highlightNode(${i})" onmouseleave="unhighlightNode()"`;
                
                return `<li class="${classes.join(' ')}" ${mouseEvents}>
                    ${label}
                    <div class="node-coords">${displayCoord1}, ${displayCoord2}</div>
                </li>`;
            }).join('');
            
            document.getElementById('vizModal').classList.add('active');
        }

        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('active');
            hoveredNodeIndex = null;
        }

        function highlightNode(index) {
            hoveredNodeIndex = index;
            
            document.querySelectorAll('.node-item').forEach((item, i) => {
                if (i === index) {
                    item.classList.add('active');
                } else {
                    item.classList.remove('active');
                }
            });
            
            if (currentMode === 'single') {
                document.querySelectorAll('.coord-highlight').forEach((span, i) => {
                    if (i === index) {
                        span.classList.add('active');
                    } else {
                        span.classList.remove('active');
                    }
                });
            }
            
            if (currentCanvasId && originalPolygonCoords) {
                drawPolygon(currentCanvasId, originalPolygonCoords);
            }
        }

        function unhighlightNode() {
            hoveredNodeIndex = null;
            
            document.querySelectorAll('.node-item').forEach(item => {
                item.classList.remove('active');
            });
            
            document.querySelectorAll('.coord-highlight').forEach(span => {
                span.classList.remove('active');
            });
            
            if (currentCanvasId && originalPolygonCoords) {
                drawPolygon(currentCanvasId, originalPolygonCoords);
            }
        }

        function handleCanvasHover(e, canvas, coords) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const transform = canvas.coordTransform;
            if (!transform) return;
            
            const { scale, offsetX, offsetY } = transform;
            
            let foundNode = -1;
            const threshold = 12;
            
            for (let i = 0; i < coords.length; i++) {
                const x = coords[i][0];
                const y = coords[i][1];
                const px = x * scale + offsetX;
                const py = canvas.height - (y * scale + offsetY);
                
                const dist = Math.sqrt(Math.pow(mouseX - px, 2) + Math.pow(mouseY - py, 2));
                if (dist < threshold) {
                    foundNode = i;
                    break;
                }
            }
            
            if (foundNode !== hoveredNodeIndex) {
                if (foundNode >= 0) {
                    highlightNode(foundNode);
                    // Show bubble for single canvas only
                    if (canvas.id === 'singleCanvas' && lockedNodeIndex === null) {
                        showCoordBubble(foundNode, e.clientX, e.clientY);
                    }
                } else {
                    unhighlightNode();
                    if (canvas.id === 'singleCanvas' && lockedNodeIndex === null) {
                        hideCoordBubble();
                    }
                }
            } else if (foundNode >= 0 && canvas.id === 'singleCanvas' && lockedNodeIndex === null) {
                // Update bubble position if still hovering same node
                updateBubblePosition(e.clientX, e.clientY);
            }
        }

        function showCoordBubble(nodeIndex, mouseX, mouseY) {
            if (!currentPolygonCoords) return;
            
            const bubble = document.getElementById('coordBubble');
            const coord = currentPolygonCoords[nodeIndex];
            
            // Format based on current mode
            const display1 = coord[0];
            const display2 = coord[1];
            const label = isOrbitMode ? 'Long, Lat' : 'Lat, Long';
            
            bubble.textContent = `Node ${nodeIndex + 1}: [${display1}, ${display2}] (${label})`;
            bubble.classList.add('active');
            
            updateBubblePosition(mouseX, mouseY);
        }

        function updateBubblePosition(mouseX, mouseY) {
            const bubble = document.getElementById('coordBubble');
            const container = document.getElementById('mapContainer');
            const rect = container.getBoundingClientRect();
            
            let bubbleX = mouseX - rect.left + bubbleOffsetX;
            let bubbleY = mouseY - rect.top - 40 + bubbleOffsetY;
            
            bubble.style.left = bubbleX + 'px';
            bubble.style.top = bubbleY + 'px';
            bubble.style.transform = 'translateX(-50%)';
        }

        function hideCoordBubble() {
            const bubble = document.getElementById('coordBubble');
            bubble.classList.remove('active');
            bubbleOffsetX = 0;
            bubbleOffsetY = 0;
        }

        function lockCoordBubble(nodeIndex) {
            const bubble = document.getElementById('coordBubble');
            lockedNodeIndex = nodeIndex;
            bubble.classList.add('locked');
        }

        function unlockCoordBubble() {
            const bubble = document.getElementById('coordBubble');
            lockedNodeIndex = null;
            bubble.classList.remove('locked');
            hideCoordBubble();
        }

        function autoClosePolygon() {
            const jsonInput = document.getElementById('jsonInput');
            const jsonValue = jsonInput.value.trim();
            
            if (!jsonValue) {
                alert('Please paste a polygon first');
                return;
            }
            
            try {
                const polygon = JSON.parse(jsonValue);
                
                if (polygon.type === 'Point') {
                    alert('Cannot auto-close a Point geometry');
                    return;
                }
                
                if (!polygon.coordinates || !polygon.coordinates[0]) {
                    alert('Invalid polygon format');
                    return;
                }
                
                const coords = polygon.coordinates[0];
                
                if (coords.length < 2) {
                    alert('Need at least 2 coordinates to close a polygon');
                    return;
                }
                
                const firstCoord = coords[0];
                const lastCoord = coords[coords.length - 1];
                
                // Check if already closed
                if (firstCoord[0] === lastCoord[0] && firstCoord[1] === lastCoord[1]) {
                    alert('Polygon is already closed!');
                    return;
                }
                
                // Add first coordinate to the end
                polygon.coordinates[0].push([firstCoord[0], firstCoord[1]]);
                
                // Update input
                jsonInput.value = JSON.stringify(polygon);
                
                // Auto-validate
                validateSingle();
                
            } catch (e) {
                alert('Invalid JSON: ' + e.message);
            }
        }

        function openHelp() {
            document.getElementById('helpModal').classList.add('active');
        }

        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                closeModal('vizModal');
                closeModal('helpModal');
            }
        });

        document.querySelectorAll('.modal').forEach(modal => {
            modal.addEventListener('click', function(e) {
                if (e.target === this) {
                    this.classList.remove('active');
                }
            });
        });

        window.addEventListener('resize', function() {
            if (originalPolygonCoords) {
                if (currentMode === 'single') {
                    drawPolygon('singleCanvas', originalPolygonCoords);
                } else if (document.getElementById('vizModal').classList.contains('active')) {
                    drawPolygon('modalCanvas', originalPolygonCoords);
                }
            }
        });

        // Wait for DOM to be ready before adding bubble drag listeners
        document.addEventListener('DOMContentLoaded', function() {
            const coordBubble = document.getElementById('coordBubble');
            
            if (coordBubble) {
                coordBubble.addEventListener('mousedown', function(e) {
                    if (!this.classList.contains('locked')) return;
                    
                    isDraggingBubble = true;
                    bubbleDragStartX = e.clientX;
                    bubbleDragStartY = e.clientY;
                    this.classList.add('dragging');
                    e.stopPropagation();
                });
            }
        });

        document.addEventListener('mousemove', function(e) {
            if (!isDraggingBubble) return;
            
            const deltaX = e.clientX - bubbleDragStartX;
            const deltaY = e.clientY - bubbleDragStartY;
            
            bubbleOffsetX += deltaX;
            bubbleOffsetY += deltaY;
            
            bubbleDragStartX = e.clientX;
            bubbleDragStartY = e.clientY;
            
            // Update bubble position
            const bubble = document.getElementById('coordBubble');
            if (!bubble) return;
            
            const currentLeft = parseFloat(bubble.style.left) || 0;
            const currentTop = parseFloat(bubble.style.top) || 0;
            
            bubble.style.left = (currentLeft + deltaX) + 'px';
            bubble.style.top = (currentTop + deltaY) + 'px';
        });

        document.addEventListener('mouseup', function() {
            if (isDraggingBubble) {
                isDraggingBubble = false;
                const bubble = document.getElementById('coordBubble');
                if (bubble) bubble.classList.remove('dragging');
            }
        });

        const singleCanvas = document.getElementById('singleCanvas');
        
        // Smooth zoom with mouse wheel
        singleCanvas.addEventListener('wheel', function(e) {
            if (!originalPolygonCoords || currentMode !== 'single') return;
            e.preventDefault();
            
            const delta = e.deltaY > 0 ? 0.95 : 1.05; // Smooth increments
            const newZoom = zoomLevel * delta;
            
            if (newZoom >= 0.3 && newZoom <= 5) {
                zoomLevel = newZoom;
                drawPolygon('singleCanvas', originalPolygonCoords);
            }
        });
        
        // Pan with click and drag
        singleCanvas.addEventListener('mousedown', function(e) {
            if (!originalPolygonCoords || currentMode !== 'single') return;
            isDraggingMap = true;
            mapDragStartX = e.clientX;
            mapDragStartY = e.clientY;
            singleCanvas.style.cursor = 'grabbing';
        });
        
        singleCanvas.addEventListener('mousemove', function(e) {
            if (!originalPolygonCoords || currentMode !== 'single') return;
            
            if (isDraggingMap) {
                const deltaX = e.clientX - mapDragStartX;
                const deltaY = e.clientY - mapDragStartY;
                
                panOffsetX += deltaX;
                panOffsetY -= deltaY;  // Inverted Y-axis for natural panning
                
                mapDragStartX = e.clientX;
                mapDragStartY = e.clientY;
                
                drawPolygon('singleCanvas', originalPolygonCoords);
            } else {
                handleCanvasHover(e, this, originalPolygonCoords);
            }
        });
        
        singleCanvas.addEventListener('mouseup', function() {
            if (currentMode !== 'single') return;
            isDraggingMap = false;
            singleCanvas.style.cursor = 'crosshair';
        });
        
        singleCanvas.addEventListener('mouseleave', function() {
            if (currentMode !== 'single') return;
            isDraggingMap = false;
            singleCanvas.style.cursor = 'crosshair';
            if (lockedNodeIndex === null) {
                unhighlightNode();
                hideCoordBubble();
            }
        });

        singleCanvas.addEventListener('click', function(e) {
            if (!originalPolygonCoords || currentMode !== 'single') return;
            if (isDraggingMap) return; // Don't lock if we were dragging
            
            const rect = this.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const transform = this.coordTransform;
            if (!transform) return;
            
            const { scale, offsetX, offsetY } = transform;
            
            let foundNode = -1;
            const threshold = 12;
            
            for (let i = 0; i < originalPolygonCoords.length; i++) {
                const x = originalPolygonCoords[i][0];
                const y = originalPolygonCoords[i][1];
                const px = x * scale + offsetX;
                const py = this.height - (y * scale + offsetY);
                
                const dist = Math.sqrt(Math.pow(mouseX - px, 2) + Math.pow(mouseY - py, 2));
                if (dist < threshold) {
                    foundNode = i;
                    break;
                }
            }
            
            if (foundNode >= 0) {
                if (lockedNodeIndex === foundNode) {
                    unlockCoordBubble();
                } else {
                    lockCoordBubble(foundNode);
                    showCoordBubble(foundNode, e.clientX, e.clientY);
                }
            } else {
                unlockCoordBubble();
            }
        });

        const modalCanvas = document.getElementById('modalCanvas');
        
        modalCanvas.addEventListener('mousemove', function(e) {
            if (!originalPolygonCoords) return;
            handleCanvasHover(e, this, originalPolygonCoords);
        });
        
        modalCanvas.addEventListener('mouseleave', function() {
            unhighlightNode();
        });
    </script>
</body>
</html>